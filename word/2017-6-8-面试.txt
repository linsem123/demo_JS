WEB前端：
1.数据类型
	if(null == undefined)->true
	上面的原因是将undefined类型转换成为null类型
	if(null === undefined)->false
	如果一个是对象,另一个是数值或字符串,把对象转换成基础类型的值再比较.对象转换成基础类型,利用它的toString或者valueOf方法.js核 心内置类,会尝试valueOf先于toString；例外的是Date,Date利用的是toString转换.非js核心的对象

2.typeof
	typeof(null)->object
	typeof(undefined)->undefined

3.px pt em rem（移动端开发）
	px：pixel，像素，屏幕上显示的最小单位，用于网页设计，直观方便；

　　pt：point，是一个标准的长度单位，1pt＝1/72英寸，用于印刷业，非常简单易用；

　　em：即％，在CSS中，1em＝100％，是一个比率，结合CSS继承关系使用，具有灵活性。

　　PPI（DPI）：pixel（dot）per inch，每英寸的像素（点）数，是一个率，表示了“清晰度”，“精度”
	pt=px乘以3/4。
	任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合: 1em=16px

	rem（font size of the root element）是指相对于根元素的字体大小的单位（可以联想一下em）适用于移动端开发

4.闭包的优点和缺点
	闭包的好处有：
	1.缓存
	2.面向对象中的对象
	3.实现封装，防止变量跑到外层作用域中，发生命名冲突
	4.匿名自执行函数，匿名自执行函数可以减小内存消耗
	闭包的坏处：
	1.内存消耗
	通常来说，函数的活动对象会随着执行期上下文一起销毁，但是，由于闭包引用另外一个函数的活动对象，因此这个活动对象无法被销毁，这意味着，闭包比一般的函数需要更多的内存消耗。尤其在IE浏览器中需要关注。由于IE使用非原生javascript对象实现DOM对象，因此闭包会导致内存泄露问题，
	2.性能问题
	使用闭包时，会涉及到跨作用域访问，每次访问都会导致性能损失。
	因此在脚本中，最好小心使用闭包，它同时会涉及到内存和速度问题。不过我们可以通过把跨作用域变量存储在局部变量中，然后直接访问局部变量，来减轻对执行速度的影响。

5.作用域以及作用域链
	作用域：作用域就是变量与函数的可访问范围
		1.全局作用域
		2.局部作用域
	作用域链：
	JavaScript中所有的量都是存在于某一个作用域中的
	除了全局作用域, 每一个作用域都是存在於某个作用域中的
	在试图访问一个变量时JS引擎会从当前作用域开始向上查找直到Global全局作用域停止

	var A;//全局作用域
	function B(){var C;//C位于B函数的作用域    
	function D(){var E;//E位于D函数的作用域        
	alert(A)
		}
	}

	当alert(A)时, JS引擎沿着D的作用域, B的作用域, 全局作用域的顺序进行查找.
	这三个作用域组成的有序集合就成为作用域链
	至于为什么叫链, 你可以理解和链表有相似之处, 深层的作用域会能够访问到上层作用域, 就如同链表中两个连续节点能够单向访问一样

6.媒体查询CSS
	定义：媒体查询可以让我们根据设备显示器的特性（如视口宽度、屏幕比例、设备方向：横向或纵向）为其设定CSS样式，媒体查询由媒体类型和一个或多个检测媒体特性的条件表达式组成。媒体查询中可用于检测的媒体特性有 width 、 height 和 color （等）。使用媒体查询，可以在不改变页面内容的情况下，为特定的一些输出设备定制显示效果。

	如果没有CSS3的媒体查询模块，就不能针对设备特性（如视口宽度）设置特定的CSS样式
	媒体查询写在CSS样式代码的最后，CSS是层叠样式表，在同一特殊性下，靠后的的样式会重叠前面的样式

	使用：
	首先需要在html文档中添加以下代码，用来兼容移动设备的显示效果
	<meta name="viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
	width=device-width:宽度等于当前设备的宽度	
	initial-scale=1：初始的缩放比例（默认为1）
	maximum-scale=1：允许用户缩放到得最大比例（默认为1）
	user-scalable=no：用户不能手动缩放
	书写媒体查询：
	@media screen and (max-width:720px) and (min-width:320px){

      body{

       background-color:red;

       }

	@media screen and (max-width:320px){

	      body{

	         background-color:blue;

	       }

	}
	含义：
	该段媒体查询的意思是：当设备屏幕宽度在320px——720px之间时，媒体查询中body的背景色（background-color:red;）会重叠之前的body背景色，当设备屏幕宽度在320px以下时，媒体查询中body的body背景色（background-color:blue;）会重叠之前的body背景色

7.响应式布局的原理
	响应式布局是Ethan Marcotte在2010年5月份提出的一个概念，简而言之，就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的。Web设计应该做到根据不同设备环境自动响应及调整。当然响应式Web设计不仅仅是关于屏幕分辨率自适应以及自动缩放的图片等等，它更像是一种对于设计的全新思维模式；我们应当向下兼容、移动优先。
	优点：
	面对不同分辨率设备灵活性强
	能够快捷解决多设备显示适应问题
	缺点：
	兼容各种设备工作量大，效率低下
	代码累赘，会出现隐藏无用的元素，加载时间加长
	其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果
	一定程度上改变了网站原有的布局结构，会出现用户混淆的情况
	详细了解：http://www.mahaixiang.cn/wzsj/278.html
	
JAVA：
1.基本变量类型八种
	1.整型 int
	2.短整型 short
	3.长整型 long
	4.字节型 byte
	5.布尔型 boolean
	6.字符型 char
	7.单精度浮点数 float
	8.双精度浮点数 double
2.反射
	反射的原理：
	java虚拟机有一个运行时的数据区，这个数据区又被分为方法区，堆区，栈区。这里主要用到的是方法区。方法区的主要作用就是存储被加载的类的信息，当java虚拟机转载某一个类的时候，需要类加载器定位相应的class文件，然后将其读入到java虚拟机中，紧接着虚拟机提取class中的类型信息，将这些信息存储到方法区。
	要让Java程序能够运行，那么就得让Java类要被Java虚拟机加载。Java类如果不被Java虚拟机加载，是不能正常运行的。现在我们运行的所有的程序都是在编译期的时候就已经知道了你所需要的那个类的已经被加载了。
	所谓的反射就是java语言在运行时拥有一项自观的能力,反射使您的程序代码能够得到装载到JVM中的类的内部信息,允许您执行程序时才得到需要类。Java的反射机制是在编译并不确定是哪个类被加载了，而是在程序运行的时候才加载、探知、自审。使用在编译期并不知道的类。这样的特点就是反射。
	Hibernate是一个屏蔽JDBC，实现了ORM的Java框架，利用该框架我们可以抛弃繁琐的sql语句，而是利用了Hibernate中的Session类的save()方法直接将某一个类的对象存到数据库中，也就是涉及到sql语句的那些代码Hibernate帮我们做了，